"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractMessageChannel = void 0;
var tslib_1 = require("tslib");
var createDeferred_1 = require("@trezor/utils/lib/createDeferred");
var typedEventEmitter_1 = require("@trezor/utils/lib/typedEventEmitter");
var scheduleAction_1 = require("@trezor/utils/lib/scheduleAction");
var AbstractMessageChannel = (function (_super) {
    tslib_1.__extends(AbstractMessageChannel, _super);
    function AbstractMessageChannel(_a) {
        var sendFn = _a.sendFn, channel = _a.channel, logger = _a.logger;
        var _this = _super.call(this) || this;
        _this.messagePromises = {};
        _this.messagesQueue = [];
        _this.messageID = 0;
        _this.handshakeMaxRetries = 5;
        _this.handshakeRetryInterval = 2000;
        _this.channel = channel;
        _this.sendFn = sendFn;
        _this.logger = logger;
        return _this;
    }
    AbstractMessageChannel.prototype.init = function () {
        if (!this.handshakeFinished) {
            this.handshakeFinished = (0, createDeferred_1.createDeferred)();
            this.handshakeWithPeer();
        }
        return this.handshakeFinished.promise;
    };
    AbstractMessageChannel.prototype.handshakeWithPeer = function () {
        var _this = this;
        var _a;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.log(this.channel.here, 'handshake');
        return (0, scheduleAction_1.scheduleAction)(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.postMessage({
                            type: 'channel-handshake-request',
                            data: { success: true, payload: undefined },
                        }, { usePromise: false, useQueue: false });
                        return [4, ((_a = this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.promise)];
                    case 1:
                        _b.sent();
                        return [2];
                }
            });
        }); }, {
            attempts: this.handshakeMaxRetries,
            timeout: this.handshakeRetryInterval,
        })
            .then(function () {
            var _a;
            (_a = _this.logger) === null || _a === void 0 ? void 0 : _a.log(_this.channel.here, 'handshake confirmed');
            _this.messagesQueue.forEach(function (message) {
                message.channel = _this.channel;
                _this.sendFn(message);
            });
            _this.messagesQueue = [];
        })
            .catch(function () {
            var _a;
            (_a = _this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.reject(new Error('handshake failed'));
            _this.handshakeFinished = undefined;
        });
    };
    AbstractMessageChannel.prototype.onMessage = function (message) {
        var _a;
        var channel = message.channel, id = message.id, type = message.type, payload = message.payload, success = message.success;
        if (!(channel === null || channel === void 0 ? void 0 : channel.peer) || channel.peer !== this.channel.here) {
            return;
        }
        if (!(channel === null || channel === void 0 ? void 0 : channel.here) || this.channel.peer !== channel.here) {
            return;
        }
        if (type === 'channel-handshake-request') {
            this.postMessage({
                type: 'channel-handshake-confirm',
                data: { success: true, payload: undefined },
            }, { usePromise: false, useQueue: false });
            return;
        }
        if (type === 'channel-handshake-confirm') {
            (_a = this.handshakeFinished) === null || _a === void 0 ? void 0 : _a.resolve(undefined);
            return;
        }
        if (this.messagePromises[id]) {
            this.messagePromises[id].resolve({ id: id, payload: payload, success: success });
            delete this.messagePromises[id];
        }
        var messagePromisesLength = Object.keys(this.messagePromises).length;
        if (messagePromisesLength > 5) {
            this.logger.warn("too many message promises (".concat(messagePromisesLength, "). this feels unexpected!"));
        }
        this.emit('message', message);
    };
    AbstractMessageChannel.prototype.postMessage = function (message, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.usePromise, usePromise = _c === void 0 ? true : _c, _d = _b.useQueue, useQueue = _d === void 0 ? true : _d;
        message.channel = this.channel;
        if (!usePromise) {
            try {
                this.sendFn(message);
            }
            catch (err) {
                if (useQueue) {
                    this.messagesQueue.push(message);
                }
            }
            return;
        }
        this.messageID++;
        message.id = this.messageID;
        this.messagePromises[message.id] = (0, createDeferred_1.createDeferred)();
        try {
            this.sendFn(message);
        }
        catch (err) {
            if (useQueue) {
                this.messagesQueue.push(message);
            }
        }
        return this.messagePromises[message.id].promise;
    };
    return AbstractMessageChannel;
}(typedEventEmitter_1.TypedEmitter));
exports.AbstractMessageChannel = AbstractMessageChannel;
//# sourceMappingURL=abstract.js.map