"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseWebsocket = void 0;
const tslib_1 = require("tslib");
const ws_1 = tslib_1.__importDefault(require("ws"));
const createDeferred_1 = require("@trezor/utils/lib/createDeferred");
const typedEventEmitter_1 = require("@trezor/utils/lib/typedEventEmitter");
const errors_1 = require("@trezor/blockchain-link-types/lib/constants/errors");
const DEFAULT_TIMEOUT = 20 * 1000;
const DEFAULT_PING_TIMEOUT = 50 * 1000;
class BaseWebsocket extends typedEventEmitter_1.TypedEmitter {
    constructor(options) {
        super();
        this.messages = [];
        this.subscriptions = [];
        this.emitter = this;
        this.messageID = 0;
        this.options = options;
    }
    setConnectionTimeout(timeout) {
        this.clearConnectionTimeout();
        this.connectionTimeout = setTimeout(this.onTimeout.bind(this), timeout || this.options.timeout || DEFAULT_TIMEOUT);
    }
    clearConnectionTimeout() {
        if (this.connectionTimeout) {
            clearTimeout(this.connectionTimeout);
            this.connectionTimeout = undefined;
        }
    }
    setPingTimeout() {
        if (this.pingTimeout) {
            clearTimeout(this.pingTimeout);
        }
        this.pingTimeout = setTimeout(this.onPing.bind(this), this.options.pingTimeout || DEFAULT_PING_TIMEOUT);
    }
    rejectAllPending(code, message) {
        this.messages.forEach(m => m.reject(new errors_1.CustomError(code, message)));
        this.messages.splice(0, this.messages.length);
    }
    onTimeout() {
        const { ws } = this;
        if (!ws)
            return;
        if (ws.listenerCount('open') > 0) {
            ws.emit('error', new errors_1.CustomError('websocket_timeout'));
            try {
                ws.close();
            }
            catch (error) {
            }
        }
        else {
            this.rejectAllPending('websocket_timeout');
            ws.close();
        }
    }
    onPing() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.ws && this.isConnected()) {
                try {
                    if (this.subscriptions.length > 0 || this.options.keepAlive) {
                        yield this.ping();
                    }
                    else {
                        this.ws.close();
                    }
                }
                catch (error) {
                }
            }
        });
    }
    onError() {
        this.onClose();
    }
    sendMessage(message) {
        var _a, _b;
        const { ws } = this;
        if (!ws)
            throw new errors_1.CustomError('websocket_not_initialized');
        const id = this.messageID.toString();
        const dfd = (0, createDeferred_1.createDeferred)(id);
        const req = Object.assign({ id }, message);
        this.messageID++;
        this.messages.push(dfd);
        this.setConnectionTimeout();
        this.setPingTimeout();
        (_b = (_a = this.options).onSending) === null || _b === void 0 ? void 0 : _b.call(_a, message);
        ws.send(JSON.stringify(req));
        return dfd.promise;
    }
    onMessage(message) {
        try {
            const resp = JSON.parse(message);
            const { id, data } = resp;
            const dfd = this.messages.find(m => m.id === id);
            if (dfd) {
                if (data.error) {
                    dfd.reject(new errors_1.CustomError('websocket_error_message', data.error.message));
                }
                else {
                    dfd.resolve(data);
                }
                this.messages.splice(this.messages.indexOf(dfd), 1);
            }
            else {
                const subs = this.subscriptions.find(s => s.id === id);
                if (subs) {
                    subs.callback(data);
                }
            }
        }
        catch (error) {
        }
        if (this.messages.length === 0) {
            this.clearConnectionTimeout();
        }
        this.setPingTimeout();
    }
    addSubscription(type, callback) {
        const id = this.messageID.toString();
        this.subscriptions.push({ id, type, callback });
    }
    removeSubscription(type) {
        const index = this.subscriptions.findIndex(s => s.type === type);
        if (index >= 0) {
            this.subscriptions.splice(index, 1);
        }
        return index;
    }
    connect() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.connectPromise) {
                return this.connectPromise;
            }
            if (((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) === ws_1.default.CLOSING) {
                yield new Promise(resolve => this.emitter.once('disconnected', resolve));
            }
            this.setConnectionTimeout(this.options.connectionTimeout);
            const dfd = (0, createDeferred_1.createDeferred)(-1);
            this.connectPromise = dfd.promise;
            const ws = this.createWebsocket();
            ws.once('error', error => {
                this.onClose();
                dfd.reject(new errors_1.CustomError('websocket_runtime_error', error.message));
            });
            ws.on('open', () => {
                this.init();
                dfd.resolve();
            });
            this.ws = ws;
            return dfd.promise.finally(() => {
                this.connectPromise = undefined;
            });
        });
    }
    init() {
        const { ws } = this;
        if (!ws || !this.isConnected()) {
            throw Error('Websocket init cannot be called');
        }
        this.clearConnectionTimeout();
        ws.removeAllListeners();
        ws.on('error', this.onError.bind(this));
        ws.on('message', this.onMessage.bind(this));
        ws.on('close', () => {
            this.onClose();
            this.emitter.emit('disconnected');
        });
    }
    disconnect() {
        var _a;
        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();
    }
    isConnected() {
        var _a;
        return ((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) === ws_1.default.OPEN;
    }
    onClose() {
        var _a;
        if (this.pingTimeout) {
            clearTimeout(this.pingTimeout);
        }
        if (this.connectionTimeout) {
            clearTimeout(this.connectionTimeout);
        }
        if (this.isConnected()) {
            this.disconnect();
        }
        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.removeAllListeners();
        this.rejectAllPending('websocket_runtime_error', 'Websocket closed unexpectedly');
    }
    dispose() {
        this.onClose();
        this.removeAllListeners();
    }
}
exports.BaseWebsocket = BaseWebsocket;
//# sourceMappingURL=baseWebsocket.js.map